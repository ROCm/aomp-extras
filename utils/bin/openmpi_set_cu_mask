#!/bin/bash
#
#  openmpi_set_cu_mask: Script that reads OpenMPI environment variables and
#                       builds HSA_CU_MASK accordingly then launches
#                       the MPI process. This script demonstrates how to
#                       distribute a GPU across multiple ranks of an MPI
#                       job into mutually exclusive CU sets and across
#                       multiple devices.
#
#  Limitations:
#  1 Only works with AOMP 15.0-0 or greater.
#  2 Only works with OpenMPI because OpenMPI sets certain environment variables
#  3 Only creates masks that are mutually exclusive of each other.
#    That is, the MPI processes will not share CUs.
#  4 Because of 4, this demo script only works when number of CUs is
#    divisible by number of local MPI processes.
#
#  Example Usage:
#  mpirun -np 4 /usr/lib/aomp/bin/openmpi_set_cu_mask <MPI_APP_BINARY> <MPI_APP_ARGS>
#  mpirun -np 6 /usr/lib/aomp/bin/openmpi_set_cu_mask
#
#  Written by Greg Rodgers 
#  Copyright (c) 2021 ADVANCED MICRO DEVICES, INC.
#  Updated on 3/11 by Greg Rodgers to work with multiple devices
#  Copyright (c) 2022 ADVANCED MICRO DEVICES, INC.

PROGVERSION=X.Y-Z
function version(){
   echo $0 version $PROGVERSION
   exit 0
}
[ "$1" == "--version" ] && version

#  Get environment variables set by OpenMPI
_num_local_ranks=$OMPI_COMM_WORLD_LOCAL_SIZE
_local_rank_num=$OMPI_COMM_WORLD_LOCAL_RANK
if [ -z "$_num_local_ranks" ] ; then
   echo "ERROR: $0 is intended to be run with OpenMPI (mpirun)"
   exit 1
fi

AOMP=${AOMP:-_AOMP_INSTALL_DIR_}
if [ ! -d $AOMP ] ; then
   AOMP="_AOMP_INSTALL_DIR_"
fi
if [ ! -d $AOMP ] ; then
   echo "ERROR: AOMP not found at $AOMP"
   echo "       Please install AOMP or correctly set env-var AOMP"
   exit 1
fi
if [ ! -f $AOMP/bin/rocminfo ] ; then
   echo "ERROR: Could not find binary $AOMP/bin/rocminfo"
   echo "       Please correct the installation of AOMP"
   exit 1
fi
# Get number of GPUS from rocm_agent_enumerator
_actual_num_devices=`$AOMP/bin/rocm_agent_enumerator | wc -l`
_actual_num_devices=$(( $_actual_num_devices - 1 ))
if [[ $_actual_num_devices -lt 1  ]] ; then
   echo "ERROR: No GPUS available"
   exit 1
fi

# Find GPU with largest number of CUs
_number_of_CUs=0
for last_cu_count in `$AOMP/bin/rocminfo | grep -E "Compute Unit:| Device Type:" | cut -d":" -f2` ; do
  if [ $last_cu_count == "CPU" ] ; then 
     _last_device_type_was_gpu=0
  elif [ $last_cu_count == "GPU" ] ; then 
     _last_device_type_was_gpu=1
  else
     if [[ $_last_device_type_was_gpu == 1 ]] ; then
        if [[ $last_cu_count -gt $_number_of_CUs ]] ; then
            _number_of_CUs=$last_cu_count
        fi
     fi
  fi
done

# Calculate number of GPUs to use to evenly spread ranks across GPUs
_num_devices=$_actual_num_devices
_rem1=$(( $_num_local_ranks % $_num_devices ))
while [ $_rem1 != 0 ] ; do
   _num_devices=$(( $_num_devices - 1 ))
   _rem1=$(( $_num_local_ranks % $_num_devices ))
done
if [ $_actual_num_devices != $_num_devices ] ; then
   # give warning on rank 0 if number of devices were trimmed
   if [ $_local_rank_num == 0 ] ; then
      echo "WARNING: The number of MPI ranks cannot be divided by available GPUs"
      echo "         The number of MPI ranks: $_num_local_ranks"
      echo "         Available GPUs:          $_actual_num_devices"
      echo "         Selected number of GPUs: $_num_devices"
   fi
fi
_total_number_of_CUs=$(( $_num_devices * $_number_of_CUs ))
_num_local_ranks_per_GPU=$(( $_num_local_ranks / $_num_devices ))
_number_of_CUs_per_GPU=$(( $_total_number_of_CUs / $_num_devices ))
_device_num=$(( $_local_rank_num / $_num_local_ranks_per_GPU ))
_relative_rank_num=$(( $_local_rank_num / $_num_devices ))

# This script is only tested where CUs can be divided evenly across MPI ranks
_rem2=$(($_total_number_of_CUs%_num_local_ranks))
if [ $_rem2 != 0 ] ; then
   echo "ERROR: The total number of CUs ($_total_number_of_CUs) can not be divided by $_num_local_ranks"
   echo "       The number of CUs per GPU is: $_number_of_CUs"
   echo "       The number of GPUs is: $_num_devices"
   exit 1
fi

#  Build the CU mask for this rank
_bits_to_set=$(( $_number_of_CUs / $_num_local_ranks_per_GPU ))
#  This formula keeps adjacent ranks on same GPU which should be preferred
_bits_to_shift=$(( ( $_local_rank_num * $_bits_to_set) - ( _device_num * $_number_of_CUs_per_GPU) ))
# use bc because these values can be very large
_unshifted_bits=`echo "(2 ^ $_bits_to_set) - 1" | bc`
_mask=`echo "obase=16; $_unshifted_bits * (2 ^ $_bits_to_shift)" | bc`
# Calculate the number of leading zeros needed for this mask
_lz=$(( ( $_number_of_CUs / 4 ) - ${#_mask} + 1 ))
for i in `seq 1 $_lz` ; do
    _mask="0$_mask"
done
_mask="0x$_mask"

export ROCM_VISIBLE_DEVICES=$_device_num
export HSA_CU_MASK=$ROCM_VISIBLE_DEVICES:$_mask
printf "rank %4s HSA_CU_MASK %20s\n" $_local_rank_num $HSA_CU_MASK

# execute the application
$*
exit $?
