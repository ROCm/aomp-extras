#!/bin/bash
#
#  openmpi_set_cu_mask: Script that reads OpenMPI environment variables and
#                       builds HSA_CU_MASK accordingly then launches
#                       the MPI process. This script demonstrates how to
#                       distribute a GPU across multiple ranks of an MPI
#                       job into mutually exclusive CU sets and across
#                       multiple devices.
#
#  Limitations:
#  1 Only works with AOMP 15.0-0 or greater.
#  2 Only works with OpenMPI because OpenMPI sets certain environment variables
#  3 Only creates masks that are mutually exclusive of each other.
#    That is, the MPI processes will not share CUs.
#  4 Because of 4, this demo script only works when number of CUs is
#    divisible by number of local MPI processes.
#
#  Example Usage:
#  mpirun -np 4 /usr/lib/aomp/bin/openmpi_set_cu_mask <MPI_APP_BINARY> <MPI_APP_ARGS>
#  mpirun -np 6 /usr/lib/aomp/bin/openmpi_set_cu_mask
#
#  Written by Greg Rodgers 
#  Copyright (c) 2021 ADVANCED MICRO DEVICES, INC.
#  Updated on 3/11 by Greg Rodgers to work with multiple devices
#  Copyright (c) 2022 ADVANCED MICRO DEVICES, INC.


PROGVERSION=X.Y-Z
function version(){
   echo $0 version $PROGVERSION
   exit 0
}
[ "$1" == "--version" ] && version

#  Get environment variables set by OpenMPI
_num_local_ranks=$OMPI_COMM_WORLD_LOCAL_SIZE
_local_rank_num=$OMPI_COMM_WORLD_LOCAL_RANK
if [ -z "$_num_local_ranks" ] ; then
   echo "ERROR: $0 is intended to be run with OpenMPI (mpirun)"
   exit 1
fi

AOMP=${AOMP:-_AOMP_INSTALL_DIR_}
if [ ! -d $AOMP ] ; then
   AOMP="_AOMP_INSTALL_DIR_"
fi
if [ ! -d $AOMP ] ; then
   echo "ERROR: AOMP not found at $AOMP"
   echo "       Please install AOMP or correctly set env-var AOMP"
   exit 1
fi
if [ ! -f $AOMP/bin/rocminfo ] ; then
   echo "ERROR: Could not find binary $AOMP/bin/rocminfo"
   echo "       Please correct the installation of AOMP"
   exit 1
fi
# Get number of GPUS from rocm_agent_enumerator
_available_devices=`$AOMP/bin/rocm_agent_enumerator | wc -l`
_available_devices=$(( $_available_devices - 1 ))
if [[ $_available_devices -lt 1  ]] ; then
   echo "ERROR: No GPUS available"
   exit 1
fi
_available_devices=1

# Find GPU with largest number of CUs
_actual_number_of_CUs_per_GPU=0
for last_cu_count in `$AOMP/bin/rocminfo | grep -E "Compute Unit:| Device Type:" | cut -d":" -f2` ; do
  if [ $last_cu_count == "CPU" ] ; then 
     _last_device_type_was_gpu=0
  elif [ $last_cu_count == "GPU" ] ; then 
     _last_device_type_was_gpu=1
  else
     if [[ $_last_device_type_was_gpu == 1 ]] ; then
	if [[ $_actual_number_of_CUs_per_GPU == 0 ]] ; then
           _actual_number_of_CUs_per_GPU=$last_cu_count
	else
           if [[ $_actual_number_of_CUs_per_GPU != $last_cu_count ]] ; then
              echo "ERROR: Defective node! The cu_count for each GPU must be identical"
	      echo "       Last CU count : $last_cu_count"
	      echo "       Previous CU count : $_actual_number_of_CUs_per_GPU"
	      echo "       Number of GPUs : $_available_devices"
	      exit 1
           fi
        fi
     fi
  fi
done

if [ $_available_devices -gt  $_num_local_ranks ] ; then
   _num_devices=$_num_local_ranks
else
   _num_devices=$_available_devices
fi

# Calculate number of GPUs to use to evenly spread ranks across GPUs
_uncovered_ranks=$(( $_num_local_ranks % $_num_devices ))
_num_local_ranks_per_GPU=$(( $_num_local_ranks / $_num_devices ))
if [ $_uncovered_ranks != 0 ] ; then
   _num_local_ranks_per_GPU=$(( $_num_local_ranks_per_GPU + 1 ))
fi
_device_num=$(( $_local_rank_num / $_num_local_ranks_per_GPU ))
_number_of_CUs_per_GPU=$_actual_number_of_CUs_per_GPU
_rem2=$(( $_number_of_CUs_per_GPU % _num_local_ranks_per_GPU ))
# Lower number of CUs till divisible by number of ranks per GPU
while [ $_rem2 != 0 ] ; do
   _number_of_CUs_per_GPU=$(( $_number_of_CUs_per_GPU - 1 ))
   _rem2=$(( $_number_of_CUs_per_GPU % _num_local_ranks_per_GPU ))
done
_number_CUs_per_rank=$(( $_number_of_CUs_per_GPU / $_num_local_ranks_per_GPU ))

# Diagnostics:
if [ $_local_rank_num == 0 ] ; then
   echo "   RANKS: $_num_local_ranks"
   echo "   AVAILALBLE GPUS:  $_available_devices"
   echo "   USED GPUS:        $_num_devices"
   echo "   SLOTS PER GPU:    $_num_local_ranks_per_GPU"
   echo "   NUM CUs PER GPU:  $_actual_number_of_CUs_per_GPU"
   echo "   USED CUs PER GPU: $_number_of_CUs_per_GPU"
   echo "   CUs per SLOT:     $_number_CUs_per_rank"
   # calculate excess ranks
   wasted_CUs_on_each_GPU=$(( $_actual_number_of_CUs_per_GPU - $_number_of_CUs_per_GPU ))
   _total_GPU_slots=$(( $_num_local_ranks_per_GPU * $_num_devices ))
   _total_wasted_slots=$(( $_total_GPU_slots - $_num_local_ranks ))
   if [ $wasted_CUs_on_each_GPU != 0 ] || [ $_total_wasted_slots != 0 ] ; then
      echo
      echo "   WASTED CUs per GPU:       $wasted_CUs_on_each_GPU"
      echo "   WASTED SLOTS:             $_total_wasted_slots"
      echo "   WASTED GPUS:              $(( $_total_wasted_slots / $_num_local_ranks_per_GPU )) "
      echo "   WASTED SLOTS ON LAST GPU: $(( $_total_wasted_slots % $_num_local_ranks_per_GPU )) "
   fi
fi

#  Build the CU mask for this rank, bits_to_set equals _number_CUs_per_rank
_bits_to_set=$(( $_number_of_CUs_per_GPU / $_num_local_ranks_per_GPU ))
#  This formula keeps adjacent ranks on same GPU which should be preferred
_bits_to_shift=$(( ( $_local_rank_num * $_bits_to_set) - ( _device_num * $_number_of_CUs_per_GPU) ))
# use bc because these values can be very large
_unshifted_bits=`echo "(2 ^ $_bits_to_set) - 1" | bc`
_mask=`echo "obase=16; $_unshifted_bits * (2 ^ $_bits_to_shift)" | bc`
# Calculate the number of leading zeros needed for this mask
_lz=$(( ( $_number_of_CUs_per_GPU / 4 ) - ${#_mask} + 1 ))
for i in `seq 1 $_lz` ; do
    _mask="0$_mask"
done
_mask="0x$_mask"

export ROCM_VISIBLE_DEVICES=$_device_num
export HSA_CU_MASK=$ROCM_VISIBLE_DEVICES:$_mask
printf "rank %02d HSA_CU_MASK %20s\n" $_local_rank_num $HSA_CU_MASK

# execute the application
$*
exit $?
